# 2. 자주 사용하는 미들웨어

- 미들웨어는 익스프레스의 핵심이다.
- 요청과 응답의 **중간**에 위치하여 미들웨어어 부른다.
- 라우터와 에러 핸들러 또한 미들웨어의 일종이다.
- 혹은 요청과 응답을 조작하여 기능을 추가하거나 나쁜 요청을 걸러내기도 한다.
- 미들웨어는 `app.use`와 함께 사용된다.

```js
// app.js
// app.set('port', process.env.PORT || 3000);

app.use((req, res, next) => {
    console.log('모든 요청에 다 실행됩니다');
    next();
});

app.get('/', (req, res, next) => {
    console.log('GET / 요청에서만 실행됩니다');
    next();
}, (req, res) => {
    throw new Error('에러는 에러 처리 미들웨어로 갑니다');
});

app.use((err, req, res, next) => {
    console.error(err);
    res.status(500).send(err.message);
});

// app.listen(app.get('port'), () => {
```

- `next()`는 다음 미들웨어로 넘어가는 함수다.
- 이를 실행하지 않으면 다음 미들웨어가 실행되지 않는다.
- 주소를 첫 번째 인수에 넣어주지 않는다면 미들웨어는 모든 요청에서 실행된다.

| app.use(미들웨어)          | 모든 요청에서 미들웨어 실행              |
| app.use('/abc', 미들웨어)  | abc로 시작하는 요청에서 미들웨어 실행      |
| app.post('/abc', 미들웨어) | abc로 시작하는 POST 요청에서 미들웨어 실행 |

- `app.use`나 `app.get` 같은 라우터에 미들웨어를 여러 개 장착할 수 있다.
- `next()`를 호출해야 다음 미들웨어로 넘어간다.
- 에러 처리 미들웨어는 매개변수가 `err`, `req`, `res`, `next`로 4개며, 반드시 4개로 구성되어야 한다.
    - `err`에는 에러에 관한 정보가 담겨 있다.
    - `res.status` 메서드로 HTTP 상태 코드를 지정할 수 있다.
- localhost:3000에 접속하면 다음과 같이 콘솔에 출력된다.

```zsh
모든 요청에 다 실행됩니다
GET / 요청에서만 실행됩니다
Error: 에러는 에러 처리 미들웨어로 갑니다
```

- 미들웨어를 통해 요청과 응답에 다양한 기능을 추가할 수 있다.

```zsh
$ npm i morgan cookie-parser express-session dotenv
```

- `dotenv`는 `process.env`를 관리하는 패키지며, 다른 패키지는 전부 미들웨어다.
- 다음과 같이 `app.js`를 수정해본다. 또한 `.env` 파일도 작성한다.

```js
// app.js
const express = require('express');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const dotenv = require('dotenv');
const path = require('path');

dotenv.config();
const app = express();
app.set('port', process.env.PORT || 3000);
app.use(morgan('dev'));
app.use('/', express.static(path.join(__dirname, 'public')));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser(process.env.COOKIE_SECRET));
app.use(session({
    resave: false,
    saveUninitialized: false,
    secret: process.env.COOKIE_SECRET,
    cookie: {
        httpOnly: true,
        secure: false,
    },
    name: 'session-cookie',
}));

app.use((req, res, next) => {
    console.log('모든 요청에 다 실행됩니다');
    next();
});
// ...
```

```
// .env
COOKIE_SECRET=cookiesecret
```

- `dotenv` 패키지는 `.env` 파일을 읽어들여 `process.env`로 만들어준다.

## 2.1 morgan

- `morgan` 연결 후 localhost:3000에 다시 접속해보면 기존 로그 외에 추가적인 로그를 볼 수 있다.

```zsh
3000 번 포트에서 대기 중
모든 요청에 다 실행됩니다
GET / 요청에서만 실행됩니다
Error: 에러는 에러 처리 미들웨어로 갑니다
// 에러 스택 트레이스 생략
GET / 500 7.247 ms - 49
```

- `GET / 500 7.247 ms - 49` 로그는 `morgan` 미들웨어에서 출력하는 것이다.

```js
// 사용법
app.use(morgan('dev'));
```

- 인수로 `dev` 외에도 `combined`, `common`, `short`, `tiny` 등을 넣을 수 있다.

## 2.2 static

- 정적인 파일들을 제공하는 라우터 역할을 한다.
- 기본적으로 제공되기에 따로 설치할 필요 없이 `express` 객체 안에서 꺼내 장착하면 된다.

```js
// 사용법
app.use('요청 경로', express.static('실제 경로'));
app.use('/', express.static(path.join(__dirname, 'public')));
```

- 정적 파일이 담겨진 폴더를 지정하면 된다.
- 실제 서버의 폴더 경로에는 `public`이 들어 있지만 요청 주소에는 `public`이 들어가지 않는다.
- 정적 파일을 알아서 제공해주므로 `fs.readFile`로 읽어들일 필요가 없다.
- 만약 해당 파일이 없다면 알아서 `next`를 해출한다.

## 2.3 body-parse

- 요청의 본문에 있는 데이터를 해석해서 `req.body` 객체로 만들어주는 미들웨어다.
- 보통 폼 데이턴나 AJAX 요청의 데이터를 처리한다.
- 단 멀티파트 데이터는 처리하지 못한다. 이럴 떈 `multer` 모듈을 사용하면 된다.

```js
// 사용법
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
```

- `body-parser`는 express 4.16.0 버전부터 내장되어서 따로 설치할 필요는 없다.
- 직접 설치해야 하는 경우도 있는데, JSON, URL-encoded 형식 데이터 외에도 Raw, Text 형식의 데이터를 추가로 해석할 수 있다.
- Raw는 요청의 본문이 버퍼 데이터일 때, Text는 텍스트 데이터일 때 해석하는 미들웨어다.

```js
const bodyParser = require('body-parser');
app.use(bodyParser.raw());
app.use(bodyParser.text());
```

- 요청 데이터 종류를 살펴본다.
    - JSON: JSON 형식의 데이터 전달 방식
    - URL-encoded: 주소 형식으로 데이터를 보내는 방식
        - `{extended: false}`: `false`면 `querystring` 모듈을 사용한다. `true`는 `qs`.
- `body-parser`는 내부적으로 스트림을 처리해 `req.body`에 추가한다.

## 2.4 cookie-parser

- 요청에 동봉된 쿠키를 해석해 `req.cookies` 객체로 만들어준다.

```js
// app.js
app.use(cookieParser(비밀키));
```

- 첫 번째 인수로 비밀키를 넣어줄 수 있다.
- 서명된 쿠키가 있는 경우, 제공한 비밀키를 통해 해당 쿠키가 내 서버가 만든 쿠키임을 검증할 수 있다.
- 비밀키를 통해 만들어낸 서명을 쿠키 값 뒤에 붙이는데, `name=john.sign` 같은 모양이 된다.
- 서명된 쿠키는 `req.cookies` 대신 `req.signedCookies` 객체에 들어 있다.
- 쿠키 생성 및 제거는 `res.cookie`, `res.clearCookie` 메서드를 사용해야 한다.

```js
res.cookie('name', 'john', {
    expires: new Date(Date.now() + 900000),
    httpOnly: true,
    secure: true,
});
res.clearCookie('name', 'john', { httpOnly: true, secure: true });
```

- 쿠키를 지우려면, 키와 값 외에도 옵션이 정확하게 일치해야 한다.
    - 단 `expires`, `maxAge` 옵션은 일치할 필요가 없다.
- 옵션 중에는 `signed`라는 옵션이 있는데, `true`로 설정하면 쿠키 뒤에 서명이 붙는다.
- 서명을 위한 비밀 키는 `cookieParser` 미들웨어에 인수로 넣은 `process.env.COOKIE_SECRET`이 된다.
  
## 2.5 express-session

- 세션 관리용 미들웨어다.
- 세션은 사용자별로 `req.session` 객체 안에 유지된다.

```js
app.use(session({
    resave: false,
    saveUninitialized: false,
    secret: process.env.COOKIE_SECRET,
    cookie: {
        httpOnly: true,
        secure: false,
    },
    name: 'session-cookie',
}));
```

- 순서는 `cookie-parser` 미들웨어 뒤에 놓는 것이 좋다.
    - 이유는 내부적으로 `cookie-parser`를 사용했기 때문.
    - 다만 1.5 버전 이후에는 사용하지 않아서 문제 없다.
- 설정할 때 인수로 세션에 대한 설정을 받는다.
    - `resave`: 요청이 올 때마다 새로 세션을 저장할 것인가.
    - `saveUninitialized`: 세션에 저장할 내역이 없더라도 처음부터 세션을 생성할지.
- `express-session`은 세션 관리 시 클라이언트에 쿠키를 보낸다.
- 안전하게 쿠키를 전송하려면 쿠키에 서명을 추가해야 한다.
- 세션 쿠키 이름은 `name` 옵션으로 설정한다. 기본은 `connect.sid`다.
- `cookie` 옵션은 세션 쿠키에 대한 설정이다.
    - 현재는 `httpOnly=true`로 설정해 클라이언트에서 쿠키를 확인하지 못하게 했다.
    - `secure=false`를 통해 `https`가 아닌 환경에서도 사용할 수 있게 했다.
- `store`라는 옵션도 있는데, 데이터베이스 연결을 통해 세션을 유지하는 것이다.

```js
req.session.name = 'john';  // 세션 등록
req.sessionID;              // 세션 아이디 확인
req.session.destroy();      // 세션 모두 제거
```

- `express-session`으로 만들어진 `req.session` 객체에 값을 대입하거나 삭제해서 세션을 변경할 수 있다.
- 한꺼번에 삭제하라면 `req.session.destroy` 메서드를 사용한다.

-----
[HOME](./index.md)